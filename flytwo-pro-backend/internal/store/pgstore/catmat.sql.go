// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: catmat.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const getCatmatItemsWithoutEmbedding = `-- name: GetCatmatItemsWithoutEmbedding :many
SELECT id, group_code, group_name, class_code, class_name, pdm_code, pdm_name, item_code, item_description, ncm_code, search_document, embedding
FROM catmat_item
WHERE embedding IS NULL
ORDER BY item_code
LIMIT $2
OFFSET $1
`

type GetCatmatItemsWithoutEmbeddingParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetCatmatItemsWithoutEmbedding(ctx context.Context, arg GetCatmatItemsWithoutEmbeddingParams) ([]CatmatItem, error) {
	rows, err := q.db.Query(ctx, getCatmatItemsWithoutEmbedding, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CatmatItem
	for rows.Next() {
		var i CatmatItem
		if err := rows.Scan(
			&i.ID,
			&i.GroupCode,
			&i.GroupName,
			&i.ClassCode,
			&i.ClassName,
			&i.PdmCode,
			&i.PdmName,
			&i.ItemCode,
			&i.ItemDescription,
			&i.NcmCode,
			&i.SearchDocument,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCatmatByEmbedding = `-- name: SearchCatmatByEmbedding :many
SELECT catmat_search_embedding
FROM catmat_search_embedding(
    p_embedding  => $1::vector(1536),
    p_group_code => $2,
    p_class_code => $3,
    p_pdm_code   => $4,
    p_ncm_code   => $5,
    p_limit      => $6,
    p_offset     => $7
)
`

type SearchCatmatByEmbeddingParams struct {
	Embedding pgvector_go.Vector `json:"embedding"`
	GroupCode pgtype.Int2        `json:"group_code"`
	ClassCode pgtype.Int4        `json:"class_code"`
	PdmCode   pgtype.Int4        `json:"pdm_code"`
	NcmCode   pgtype.Text        `json:"ncm_code"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

func (q *Queries) SearchCatmatByEmbedding(ctx context.Context, arg SearchCatmatByEmbeddingParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, searchCatmatByEmbedding,
		arg.Embedding,
		arg.GroupCode,
		arg.ClassCode,
		arg.PdmCode,
		arg.NcmCode,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var catmat_search_embedding interface{}
		if err := rows.Scan(&catmat_search_embedding); err != nil {
			return nil, err
		}
		items = append(items, catmat_search_embedding)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCatmatByFTS = `-- name: SearchCatmatByFTS :many
SELECT catmat_search_fts
FROM catmat_search_fts(
    p_query      => $1,
    p_group_code => $2,
    p_class_code => $3,
    p_pdm_code   => $4,
    p_ncm_code   => $5,
    p_limit      => $6,
    p_offset     => $7
)
`

type SearchCatmatByFTSParams struct {
	Query     pgtype.Text `json:"query"`
	GroupCode pgtype.Int2 `json:"group_code"`
	ClassCode pgtype.Int4 `json:"class_code"`
	PdmCode   pgtype.Int4 `json:"pdm_code"`
	NcmCode   pgtype.Text `json:"ncm_code"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) SearchCatmatByFTS(ctx context.Context, arg SearchCatmatByFTSParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, searchCatmatByFTS,
		arg.Query,
		arg.GroupCode,
		arg.ClassCode,
		arg.PdmCode,
		arg.NcmCode,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var catmat_search_fts interface{}
		if err := rows.Scan(&catmat_search_fts); err != nil {
			return nil, err
		}
		items = append(items, catmat_search_fts)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCatmatItemEmbedding = `-- name: UpdateCatmatItemEmbedding :one
UPDATE catmat_item
SET embedding = $1::vector(1536)
WHERE item_code = $2
RETURNING id, group_code, group_name, class_code, class_name, pdm_code, pdm_name, item_code, item_description, ncm_code, search_document, embedding
`

type UpdateCatmatItemEmbeddingParams struct {
	Embedding pgvector_go.Vector `json:"embedding"`
	ItemCode  int32              `json:"item_code"`
}

func (q *Queries) UpdateCatmatItemEmbedding(ctx context.Context, arg UpdateCatmatItemEmbeddingParams) (CatmatItem, error) {
	row := q.db.QueryRow(ctx, updateCatmatItemEmbedding, arg.Embedding, arg.ItemCode)
	var i CatmatItem
	err := row.Scan(
		&i.ID,
		&i.GroupCode,
		&i.GroupName,
		&i.ClassCode,
		&i.ClassName,
		&i.PdmCode,
		&i.PdmName,
		&i.ItemCode,
		&i.ItemDescription,
		&i.NcmCode,
		&i.SearchDocument,
		&i.Embedding,
	)
	return i, err
}

const upsertCatmatItem = `-- name: UpsertCatmatItem :one
INSERT INTO catmat_item (
    group_code,
    group_name,
    class_code,
    class_name,
    pdm_code,
    pdm_name,
    item_code,
    item_description,
    ncm_code
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
ON CONFLICT (item_code)
DO UPDATE SET
    group_code      = EXCLUDED.group_code,
    group_name      = EXCLUDED.group_name,
    class_code      = EXCLUDED.class_code,
    class_name      = EXCLUDED.class_name,
    pdm_code        = EXCLUDED.pdm_code,
    pdm_name        = EXCLUDED.pdm_name,
    item_description = EXCLUDED.item_description,
    ncm_code        = EXCLUDED.ncm_code
RETURNING id, group_code, group_name, class_code, class_name, pdm_code, pdm_name, item_code, item_description, ncm_code, search_document, embedding
`

type UpsertCatmatItemParams struct {
	GroupCode       int16       `json:"group_code"`
	GroupName       string      `json:"group_name"`
	ClassCode       int32       `json:"class_code"`
	ClassName       string      `json:"class_name"`
	PdmCode         int32       `json:"pdm_code"`
	PdmName         string      `json:"pdm_name"`
	ItemCode        int32       `json:"item_code"`
	ItemDescription string      `json:"item_description"`
	NcmCode         pgtype.Text `json:"ncm_code"`
}

func (q *Queries) UpsertCatmatItem(ctx context.Context, arg UpsertCatmatItemParams) (CatmatItem, error) {
	row := q.db.QueryRow(ctx, upsertCatmatItem,
		arg.GroupCode,
		arg.GroupName,
		arg.ClassCode,
		arg.ClassName,
		arg.PdmCode,
		arg.PdmName,
		arg.ItemCode,
		arg.ItemDescription,
		arg.NcmCode,
	)
	var i CatmatItem
	err := row.Scan(
		&i.ID,
		&i.GroupCode,
		&i.GroupName,
		&i.ClassCode,
		&i.ClassName,
		&i.PdmCode,
		&i.PdmName,
		&i.ItemCode,
		&i.ItemDescription,
		&i.NcmCode,
		&i.SearchDocument,
		&i.Embedding,
	)
	return i, err
}
