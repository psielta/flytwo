// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: catser.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const getCatserItemsWithoutEmbedding = `-- name: GetCatserItemsWithoutEmbedding :many
SELECT id, material_service_type, group_code, group_name, class_code, class_name, service_code, service_description, status, search_document, embedding
FROM catser_item
WHERE embedding IS NULL
ORDER BY service_code
LIMIT $2
OFFSET $1
`

type GetCatserItemsWithoutEmbeddingParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetCatserItemsWithoutEmbedding(ctx context.Context, arg GetCatserItemsWithoutEmbeddingParams) ([]CatserItem, error) {
	rows, err := q.db.Query(ctx, getCatserItemsWithoutEmbedding, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CatserItem
	for rows.Next() {
		var i CatserItem
		if err := rows.Scan(
			&i.ID,
			&i.MaterialServiceType,
			&i.GroupCode,
			&i.GroupName,
			&i.ClassCode,
			&i.ClassName,
			&i.ServiceCode,
			&i.ServiceDescription,
			&i.Status,
			&i.SearchDocument,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCatserByEmbedding = `-- name: SearchCatserByEmbedding :many
SELECT catser_search_embedding
FROM catser_search_embedding(
    p_embedding  => $1::vector(1536),
    p_group_code => $2,
    p_class_code => $3,
    p_status     => $4,
    p_limit      => $5,
    p_offset     => $6
)
`

type SearchCatserByEmbeddingParams struct {
	Embedding pgvector_go.Vector `json:"embedding"`
	GroupCode pgtype.Int2        `json:"group_code"`
	ClassCode pgtype.Int4        `json:"class_code"`
	Status    pgtype.Text        `json:"status"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

func (q *Queries) SearchCatserByEmbedding(ctx context.Context, arg SearchCatserByEmbeddingParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, searchCatserByEmbedding,
		arg.Embedding,
		arg.GroupCode,
		arg.ClassCode,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var catser_search_embedding interface{}
		if err := rows.Scan(&catser_search_embedding); err != nil {
			return nil, err
		}
		items = append(items, catser_search_embedding)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCatserByFTS = `-- name: SearchCatserByFTS :many
SELECT catser_search_fts
FROM catser_search_fts(
    p_query        => $1,
    p_group_code   => $2,
    p_class_code   => $3,
    p_service_code => $4,
    p_status       => $5,
    p_limit        => $6,
    p_offset       => $7
)
`

type SearchCatserByFTSParams struct {
	Query       pgtype.Text `json:"query"`
	GroupCode   pgtype.Int2 `json:"group_code"`
	ClassCode   pgtype.Int4 `json:"class_code"`
	ServiceCode pgtype.Int4 `json:"service_code"`
	Status      pgtype.Text `json:"status"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) SearchCatserByFTS(ctx context.Context, arg SearchCatserByFTSParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, searchCatserByFTS,
		arg.Query,
		arg.GroupCode,
		arg.ClassCode,
		arg.ServiceCode,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var catser_search_fts interface{}
		if err := rows.Scan(&catser_search_fts); err != nil {
			return nil, err
		}
		items = append(items, catser_search_fts)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCatserItemEmbedding = `-- name: UpdateCatserItemEmbedding :one
UPDATE catser_item
SET embedding = $1::vector(1536)
WHERE service_code = $2
RETURNING id, material_service_type, group_code, group_name, class_code, class_name, service_code, service_description, status, embedding
`

type UpdateCatserItemEmbeddingParams struct {
	Embedding   pgvector_go.Vector `json:"embedding"`
	ServiceCode int32              `json:"service_code"`
}

type UpdateCatserItemEmbeddingRow struct {
	ID                  int64           `json:"id"`
	MaterialServiceType string          `json:"material_service_type"`
	GroupCode           int16           `json:"group_code"`
	GroupName           string          `json:"group_name"`
	ClassCode           int32           `json:"class_code"`
	ClassName           string          `json:"class_name"`
	ServiceCode         int32           `json:"service_code"`
	ServiceDescription  string          `json:"service_description"`
	Status              string          `json:"status"`
	Embedding           pgvector.Vector `json:"embedding"`
}

func (q *Queries) UpdateCatserItemEmbedding(ctx context.Context, arg UpdateCatserItemEmbeddingParams) (UpdateCatserItemEmbeddingRow, error) {
	row := q.db.QueryRow(ctx, updateCatserItemEmbedding, arg.Embedding, arg.ServiceCode)
	var i UpdateCatserItemEmbeddingRow
	err := row.Scan(
		&i.ID,
		&i.MaterialServiceType,
		&i.GroupCode,
		&i.GroupName,
		&i.ClassCode,
		&i.ClassName,
		&i.ServiceCode,
		&i.ServiceDescription,
		&i.Status,
		&i.Embedding,
	)
	return i, err
}

const upsertCatserItem = `-- name: UpsertCatserItem :one
INSERT INTO catser_item (
    material_service_type,
    group_code,
    group_name,
    class_code,
    class_name,
    service_code,
    service_description,
    status
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
ON CONFLICT (service_code)
DO UPDATE SET
    material_service_type = EXCLUDED.material_service_type,
    group_code            = EXCLUDED.group_code,
    group_name            = EXCLUDED.group_name,
    class_code            = EXCLUDED.class_code,
    class_name            = EXCLUDED.class_name,
    service_description   = EXCLUDED.service_description,
    status                = EXCLUDED.status
RETURNING id, material_service_type, group_code, group_name, class_code, class_name, service_code, service_description, status
`

type UpsertCatserItemParams struct {
	MaterialServiceType string `json:"material_service_type"`
	GroupCode           int16  `json:"group_code"`
	GroupName           string `json:"group_name"`
	ClassCode           int32  `json:"class_code"`
	ClassName           string `json:"class_name"`
	ServiceCode         int32  `json:"service_code"`
	ServiceDescription  string `json:"service_description"`
	Status              string `json:"status"`
}

type UpsertCatserItemRow struct {
	ID                  int64  `json:"id"`
	MaterialServiceType string `json:"material_service_type"`
	GroupCode           int16  `json:"group_code"`
	GroupName           string `json:"group_name"`
	ClassCode           int32  `json:"class_code"`
	ClassName           string `json:"class_name"`
	ServiceCode         int32  `json:"service_code"`
	ServiceDescription  string `json:"service_description"`
	Status              string `json:"status"`
}

func (q *Queries) UpsertCatserItem(ctx context.Context, arg UpsertCatserItemParams) (UpsertCatserItemRow, error) {
	row := q.db.QueryRow(ctx, upsertCatserItem,
		arg.MaterialServiceType,
		arg.GroupCode,
		arg.GroupName,
		arg.ClassCode,
		arg.ClassName,
		arg.ServiceCode,
		arg.ServiceDescription,
		arg.Status,
	)
	var i UpsertCatserItemRow
	err := row.Scan(
		&i.ID,
		&i.MaterialServiceType,
		&i.GroupCode,
		&i.GroupName,
		&i.ClassCode,
		&i.ClassName,
		&i.ServiceCode,
		&i.ServiceDescription,
		&i.Status,
	)
	return i, err
}
